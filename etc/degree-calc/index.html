<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>丁字路角度測定アプリ</title>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1;
            min-width: 250px;
            max-width: 90vw;
            transition: all 0.3s ease;
        }
        .info-panel.collapsed {
            padding: 10px;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .toggle-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: none;
            align-items: center;
            justify-content: center;
            color: #666;
        }
        .panel-content {
            display: block;
        }
        .panel-content.hidden {
            display: none;
        }
        .compact-info {
            display: none;
        }
        
        /* スマホ対応 */
        @media (max-width: 768px) {
            .info-panel {
                top: auto;
                bottom: 10px;
                right: 10px;
                left: 10px;
                min-width: auto;
                max-height: 50vh;
                overflow-y: auto;
            }
            .info-panel.collapsed {
                max-height: auto;
                overflow: visible;
            }
            .toggle-btn {
                display: flex;
            }
            .instruction {
                font-size: 12px;
                padding: 8px;
            }
            .compact-info {
                display: flex;
                gap: 15px;
                align-items: center;
                font-size: 14px;
            }
            .compact-info .angle-result {
                margin: 0;
                font-size: 20px;
            }
            .panel-content.hidden ~ .compact-info {
                display: flex;
            }
            .info-panel:not(.collapsed) .compact-info {
                display: none;
            }
        }
        .info-panel h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
        }
        .info-panel p {
            margin: 5px 0;
            font-size: 14px;
            color: #666;
        }
        .angle-result {
            font-size: 24px;
            font-weight: bold;
            color: #2563eb;
            margin: 10px 0;
        }
        .button-group {
            margin-top: 10px;
            display: flex;
            gap: 8px;
        }
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .btn-reset {
            background-color: #dc2626;
            color: white;
        }
        .btn-reset:hover {
            background-color: #b91c1c;
        }
        .btn-clear {
            background-color: #6b7280;
            color: white;
        }
        .btn-clear:hover {
            background-color: #4b5563;
        }
        .btn-location {
            background-color: #10b981;
            color: white;
        }
        .btn-location:hover {
            background-color: #059669;
        }
        .location-control {
            position: absolute;
            top: 100px;
            left: 10px;
            z-index: 1;
        }
        .location-control button {
            background-color: white;
            color: #333;
            width: 40px;
            height: 40px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        .location-control button ion-icon {
            font-size: 24px;
        }
        .location-control button:hover {
            background-color: #f3f4f6;
        }
        .location-control button:active {
            background-color: #e5e7eb;
        }
        .location-control button:disabled {
            background-color: #d1d5db;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .instruction {
            background-color: #eff6ff;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 13px;
            color: #1e40af;
        }
        .point-info {
            font-size: 12px;
            color: #4b5563;
            margin: 3px 0;
        }
        /* ラベルのスタイル */
        .maplibregl-popup-content {
            padding: 5px 10px;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-size: 13px;
            font-weight: 600;
            pointer-events: none;
        }
        .maplibregl-popup-tip {
            display: none;
        }
        .maplibregl-popup {
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- 現在地ボタン -->
    <div class="location-control">
        <button id="locationBtn" onclick="goToCurrentLocation()" title="現在地に移動">
            <ion-icon name="locate-outline"></ion-icon>
        </button>
    </div>
    
    <div class="info-panel" id="infoPanel">
        <div class="panel-header">
            <h3>丁字路角度測定</h3>
            <button class="toggle-btn" onclick="togglePanel()">
                <ion-icon name="chevron-down" id="toggleIcon"></ion-icon>
            </button>
        </div>
        
        <div class="panel-content" id="panelContent">
            <div class="instruction">
                地図上を3回クリックして角度を測定します:<br>
                1. 角の頂点(基準点)<br>
                2. 道路A の点<br>
                3. 道路B の点
            </div>
            <p>クリック数: <span id="clickCount">0</span> / 3</p>
            <div id="pointsList"></div>
            <div class="angle-result" id="angleResult">-</div>
            <div class="button-group">
                <button class="btn-reset" onclick="resetMeasurement()">リセット</button>
                <button class="btn-clear" onclick="clearAll()">全クリア</button>
            </div>
        </div>
        
        <div class="compact-info">
            <span>クリック: <strong id="clickCountCompact">0</strong> / 3</span>
            <div class="angle-result" id="angleResultCompact">-</div>
        </div>
    </div>

    <script>
        // 地理院地図のタイルURL
        const gsiStandardUrl = 'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png';
        
        // マップの初期化
        const map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    'gsi-standard': {
                        type: 'raster',
                        tiles: [gsiStandardUrl],
                        tileSize: 256,
                        attribution: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">地理院タイル</a>'
                    }
                },
                layers: [{
                    id: 'gsi-standard-layer',
                    type: 'raster',
                    source: 'gsi-standard',
                    minzoom: 0,
                    maxzoom: 18
                }]
            },
            center: [139.7671, 35.6812], // 東京
            zoom: 15
        });

        // ナビゲーションコントロールを追加
        map.addControl(new maplibregl.NavigationControl(), 'top-left');

        // 測定用の変数
        let points = [];
        let markers = [];
        let lines = [];
        let popups = []; // ラベル用のポップアップを管理
        let currentLocationMarker = null; // 現在地マーカー
        let isPanelCollapsed = false; // パネルの状態

        // パネルの折りたたみ切り替え
        function togglePanel() {
            const panel = document.getElementById('infoPanel');
            const content = document.getElementById('panelContent');
            const icon = document.getElementById('toggleIcon');
            
            isPanelCollapsed = !isPanelCollapsed;
            
            if (isPanelCollapsed) {
                panel.classList.add('collapsed');
                content.classList.add('hidden');
                icon.setAttribute('name', 'chevron-up');
            } else {
                panel.classList.remove('collapsed');
                content.classList.remove('hidden');
                icon.setAttribute('name', 'chevron-down');
            }
        }

        // 現在地に移動する関数
        function goToCurrentLocation() {
            const btn = document.getElementById('locationBtn');
            btn.disabled = true;
            btn.style.opacity = '0.5';

            if (!navigator.geolocation) {
                alert('お使いのブラウザは位置情報に対応していません。');
                btn.disabled = false;
                btn.style.opacity = '1';
                return;
            }

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const { longitude, latitude } = position.coords;
                    
                    // 地図を現在地に移動
                    map.flyTo({
                        center: [longitude, latitude],
                        zoom: 17,
                        duration: 2000
                    });

                    // 既存の現在地マーカーを削除
                    if (currentLocationMarker) {
                        currentLocationMarker.remove();
                    }

                    // 現在地にマーカーを追加
                    currentLocationMarker = new maplibregl.Marker({
                        color: '#ef4444',
                        scale: 0.8
                    })
                    .setLngLat([longitude, latitude])
                    .addTo(map);

                    btn.disabled = false;
                    btn.style.opacity = '1';
                },
                (error) => {
                    let errorMessage = '位置情報の取得に失敗しました。';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = '位置情報の使用が許可されていません。ブラウザの設定を確認してください。';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = '位置情報が利用できません。';
                            break;
                        case error.TIMEOUT:
                            errorMessage = '位置情報の取得がタイムアウトしました。';
                            break;
                    }
                    alert(errorMessage);
                    btn.disabled = false;
                    btn.style.opacity = '1';
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        // マップのロード完了後にクリックイベントを設定
        map.on('load', () => {
            // 円弧の塗りつぶし用のソースとレイヤーを追加
            map.addSource('arc-fill', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });

            map.addLayer({
                id: 'arc-fill-layer',
                type: 'fill',
                source: 'arc-fill',
                paint: {
                    'fill-color': '#fbbf24',
                    'fill-opacity': 0.4
                }
            });

            // 円弧の線用のソースとレイヤーを追加
            map.addSource('arc-line', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });

            map.addLayer({
                id: 'arc-line-layer',
                type: 'line',
                source: 'arc-line',
                paint: {
                    'line-color': '#f59e0b',
                    'line-width': 2,
                    'line-opacity': 0.8
                }
            });

            // ライン用のソースとレイヤーを追加
            map.addSource('lines', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });

            map.addLayer({
                id: 'lines-layer',
                type: 'line',
                source: 'lines',
                paint: {
                    'line-color': '#6366f1',
                    'line-width': 3,
                    'line-opacity': 0.8
                }
            });

            // ポイント用のソースとレイヤーを追加
            map.addSource('points', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });

            map.addLayer({
                id: 'points-layer',
                type: 'circle',
                source: 'points',
                paint: {
                    'circle-radius': 8,
                    'circle-color': [
                        'case',
                        ['==', ['get', 'index'], 0], '#ef4444', // 頂点: 赤
                        ['==', ['get', 'index'], 1], '#3b82f6', // 点A: 青
                        '#10b981' // 点B: 緑
                    ],
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#ffffff'
                }
            });
        });

        // マップクリックイベント
        map.on('click', (e) => {
            if (points.length >= 3) {
                return;
            }

            const lngLat = [e.lngLat.lng, e.lngLat.lat];
            points.push(lngLat);

            // ラベルを追加
            addLabel(lngLat, points.length - 1);

            updateDisplay();

            if (points.length === 3) {
                calculateAngle();
            }
        });

        // ラベルを追加する関数
        function addLabel(lngLat, index) {
            const labels = ['基準点', '道A', '道B'];
            const colors = ['#ef4444', '#3b82f6', '#10b981'];
            
            const popup = new maplibregl.Popup({
                closeButton: false,
                closeOnClick: false,
                offset: [0, -15],
                className: 'point-label'
            })
            .setLngLat(lngLat)
            .setHTML(`<div style="color: ${colors[index]};">${labels[index]}</div>`)
            .addTo(map);
            
            popups.push(popup);
        }

        // Web Mercator投影でのピクセル座標に変換
        function lngLatToMercator(lngLat) {
            const [lng, lat] = lngLat;
            const x = lng;
            const y = Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)) * 180 / Math.PI;
            return [x, y];
        }

        // Mercator座標から緯度経度に戻す
        function mercatorToLngLat(mercator) {
            const [x, y] = mercator;
            const lng = x;
            const lat = (2 * Math.atan(Math.exp(y * Math.PI / 180)) - Math.PI / 2) * 180 / Math.PI;
            return [lng, lat];
        }

        // 2点間の距離を計算(メルカトル座標上)
        function getDistance(coord1, coord2) {
            const [x1, y1] = coord1;
            const [x2, y2] = coord2;
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // 円弧を生成する関数(メルカトル座標系で計算)
        function createArc(center, startAngle, endAngle, radius) {
            const segments = 64;
            const centerMercator = lngLatToMercator(center);
            const coordinates = [center];
            
            // 角度を正規化
            let angle1 = startAngle;
            let angle2 = endAngle;
            
            // 常に小さい方の角度を描く
            let angleDiff = angle2 - angle1;
            if (angleDiff < 0) {
                angleDiff += 2 * Math.PI;
            }
            if (angleDiff > Math.PI) {
                [angle1, angle2] = [angle2, angle1];
                angleDiff = 2 * Math.PI - angleDiff;
            }

            // 円弧を描く
            for (let i = 0; i <= segments; i++) {
                let angle;
                if (angle2 >= angle1) {
                    angle = angle1 + (angle2 - angle1) * i / segments;
                } else {
                    angle = angle1 + (angle2 + 2 * Math.PI - angle1) * i / segments;
                }
                
                const x = centerMercator[0] + radius * Math.cos(angle);
                const y = centerMercator[1] + radius * Math.sin(angle);
                
                const lngLat = mercatorToLngLat([x, y]);
                coordinates.push(lngLat);
            }
            
            coordinates.push(center);
            
            return {
                type: 'Feature',
                geometry: {
                    type: 'Polygon',
                    coordinates: [coordinates]
                }
            };
        }

        // 表示を更新
        function updateDisplay() {
            // ポイントを更新
            const pointFeatures = points.map((point, index) => ({
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: point
                },
                properties: {
                    index: index
                }
            }));

            map.getSource('points').setData({
                type: 'FeatureCollection',
                features: pointFeatures
            });

            // ラインを更新
            const lineFeatures = [];
            if (points.length >= 2) {
                lineFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: [points[0], points[1]]
                    }
                });
            }
            if (points.length === 3) {
                lineFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: [points[0], points[2]]
                    }
                });
            }

            map.getSource('lines').setData({
                type: 'FeatureCollection',
                features: lineFeatures
            });

            // クリック数を更新
            document.getElementById('clickCount').textContent = points.length;
            document.getElementById('clickCountCompact').textContent = points.length;

            // ポイントリストを更新
            const pointsList = document.getElementById('pointsList');
            const labels = ['基準点', '道A', '道B'];
            pointsList.innerHTML = points.map((point, index) => {
                return `<div class="point-info">${labels[index]}: ${point[1].toFixed(6)}, ${point[0].toFixed(6)}</div>`;
            }).join('');
        }

        // 角度を計算
        function calculateAngle() {
            const [vertex, pointA, pointB] = points;

            // メルカトル座標系に変換
            const vertexM = lngLatToMercator(vertex);
            const pointAM = lngLatToMercator(pointA);
            const pointBM = lngLatToMercator(pointB);

            // ベクトルを計算(メルカトル座標系で)
            const vectorA = [pointAM[0] - vertexM[0], pointAM[1] - vertexM[1]];
            const vectorB = [pointBM[0] - vertexM[0], pointBM[1] - vertexM[1]];

            // 内積を計算
            const dotProduct = vectorA[0] * vectorB[0] + vectorA[1] * vectorB[1];

            // ベクトルの大きさを計算
            const magnitudeA = Math.sqrt(vectorA[0] ** 2 + vectorA[1] ** 2);
            const magnitudeB = Math.sqrt(vectorB[0] ** 2 + vectorB[1] ** 2);

            // 角度を計算(ラジアンから度に変換)
            const angleRad = Math.acos(dotProduct / (magnitudeA * magnitudeB));
            const angleDeg = angleRad * (180 / Math.PI);

            // 結果を表示
            document.getElementById('angleResult').textContent = `${angleDeg.toFixed(2)}°`;
            document.getElementById('angleResultCompact').textContent = `${angleDeg.toFixed(2)}°`;

            // 円弧を描画
            drawArc(vertex, pointA, pointB, vertexM, pointAM, pointBM);
        }

        // 円弧を描画
        function drawArc(vertex, pointA, pointB, vertexM, pointAM, pointBM) {
            // 円弧の半径を計算(メルカトル座標系で)
            const distA = getDistance(vertexM, pointAM);
            const distB = getDistance(vertexM, pointBM);
            const radius = Math.min(distA, distB) * 0.3;

            // 各点への角度を計算(メルカトル座標系で)
            const angle1 = Math.atan2(pointAM[1] - vertexM[1], pointAM[0] - vertexM[0]);
            const angle2 = Math.atan2(pointBM[1] - vertexM[1], pointBM[0] - vertexM[0]);

            // 円弧の塗りつぶしを作成
            const arcFill = createArc(vertex, angle1, angle2, radius);
            map.getSource('arc-fill').setData({
                type: 'FeatureCollection',
                features: [arcFill]
            });

            // 円弧の線を作成
            const segments = 64;
            const arcLineCoords = [];
            
            let startAngle = angle1;
            let endAngle = angle2;
            
            let angleDiff = endAngle - startAngle;
            if (angleDiff < 0) {
                angleDiff += 2 * Math.PI;
            }
            if (angleDiff > Math.PI) {
                [startAngle, endAngle] = [endAngle, startAngle];
                angleDiff = 2 * Math.PI - angleDiff;
            }

            for (let i = 0; i <= segments; i++) {
                let angle;
                if (endAngle >= startAngle) {
                    angle = startAngle + (endAngle - startAngle) * i / segments;
                } else {
                    angle = startAngle + (endAngle + 2 * Math.PI - startAngle) * i / segments;
                }
                
                const x = vertexM[0] + radius * Math.cos(angle);
                const y = vertexM[1] + radius * Math.sin(angle);
                
                const lngLat = mercatorToLngLat([x, y]);
                arcLineCoords.push(lngLat);
            }

            map.getSource('arc-line').setData({
                type: 'FeatureCollection',
                features: [{
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: arcLineCoords
                    }
                }]
            });
        }

        // リセット(最新の測定のみクリア)
        function resetMeasurement() {
            points = [];
            
            // ラベルを削除
            popups.forEach(popup => popup.remove());
            popups = [];
            
            updateDisplay();
            document.getElementById('angleResult').textContent = '-';
            document.getElementById('angleResultCompact').textContent = '-';
            
            // 円弧をクリア
            map.getSource('arc-fill').setData({
                type: 'FeatureCollection',
                features: []
            });
            map.getSource('arc-line').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        // 全クリア
        function clearAll() {
            resetMeasurement();
            
            // 現在地マーカーも削除
            if (currentLocationMarker) {
                currentLocationMarker.remove();
                currentLocationMarker = null;
            }
        }
    </script>
</body>
</html>